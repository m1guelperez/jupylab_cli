content,output_type,tag,y_pred
"SETUP ASSIGN=OUTPUT_SIZE ASSIGN=1e-4 def triplet_loss_distance(y_true, y_pred): ASSIGN = K.sigmoid(ASSIGN) ASSIGN = y_pred[..., :OUTPUT_SIZE] ASSIGN = y_pred[..., OUTPUT_SIZE:2*OUTPUT_SIZE] ASSIGN = y_pred[..., 2*OUTPUT_SIZE:] ASSIGN = K.tf.reduce_sum(K.tf.square(K.tf.subtract(anchor,positive)),1) ASSIGN = K.tf.reduce_sum(K.tf.square(K.tf.subtract(anchor,negative)),1) ASSIGN = -K.tf.log(-K.tf.divide((ASSIGN),beta)+1+epsilon) ASSIGN = -K.tf.log(-K.tf.divide((OUTPUT_SIZE-ASSIGN),beta)+1+epsilon) return pos_dist + neg_dist",not_existent,1,0
"def auc(y_true, y_pred): ASSIGN = tf.metrics.ASSIGN(y_true, y_pred)[1] K.get_session().run(tf.local_variables_initializer()) return auc",not_existent,1,0
"def auc(y_true, y_pred): ASSIGN = ASSIGN.ravel() ASSIGN = ASSIGN.ravel() return roc_auc_score(ASSIGN, ASSIGN) def auc_2(ASSIGN, ASSIGN): return tf.py_func(roc_auc_score, (ASSIGN, ASSIGN), tf.double) def plot_history(histories, key='binary_crossentropy'): plt.figure(figsize=(16,10)) for name, history in histories: ASSIGN = plt.plot(history.epoch, history.history['val_'+key], '--', label=name.title()+' Val') plt.plot(history.epoch, history.history[key], color=ASSIGN[0].get_color(), label=name.title()+' Train') plt.xlabel('Epochs') plt.ylabel(key.replace('_',' ').title()) plt.legend() plt.xlim([0,max(history.epoch)]) plt.ylim([0, 0.4]) plt.show()",not_existent,1,0
"SETUP ASSIGN = 5 ASSIGN = True ASSIGN = 5 ASSIGN = StratifiedKFold(n_splits=n_folds, shuffle=True, random_state=SEED)",not_existent,1,0
"CHECKPOINT for i in range(len(val_aucs)): print('Fold_%d AUC: %.6f' % (i+1, val_aucs[i]))",not_existent,1,0
"ASSIGN = result.values[:, 1:] ASSIGN = np.mean(y_all, axis = 1) ASSIGN = result[['ID_code', 'target']] ASSIGN.to_csv('NN_submission.csv', index=None) result.to_csv('NN_all_prediction.csv', index=None) valid_X['ID_code'] = train_df['ID_code'] ASSIGN = ASSIGN[['ID_code', 'target', 'predict']].to_csv('NN_oof.csv', index=None)",not_existent,0,1
