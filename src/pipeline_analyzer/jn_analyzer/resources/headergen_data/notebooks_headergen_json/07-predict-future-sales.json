{
    "cells": [
        {
            "metadata": {
                "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
                "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
                "trusted": true
            },
            "cell_type": "code",
            "source": "import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\nimport random as rd # generating random numbers\nimport datetime # manipulating date formats\nimport matplotlib.pyplot as plt # basic plotting\nimport seaborn as sns # for prettier plots\nfrom statsmodels.tsa.arima_model import ARIMA\nfrom statsmodels.tsa.statespace.sarimax import SARIMAX\nfrom pandas.plotting import autocorrelation_plot\nfrom statsmodels.tsa.stattools import adfuller, acf, pacf,arma_order_select_ic\nimport statsmodels.formula.api as smf\nimport statsmodels.tsa.api as smt\nimport statsmodels.api as sm\nimport scipy.stats as scs\nimport warnings\nwarnings.filterwarnings(\"ignore\")",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "_uuid": "d629ff2d2480ee46fbb7e2d37f6b5fab8052498a",
                "_cell_guid": "79c7e3d0-c299-4dcb-8224-4455121ee9b0",
                "trusted": true
            },
            "cell_type": "code",
            "source": "sales=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/sales_train.csv\")\nitem_cat=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/item_categories.csv\")\nitem=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/items.csv\")\nsub=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/sample_submission.csv\")\nshops=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/shops.csv\")\ntest=pd.read_csv(\"../input/competitive-data-science-predict-future-sales/test.csv\")\n",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "sales.date=sales.date.apply(lambda x:datetime.datetime.strptime(x, '%d.%m.%Y'))",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "monthly_sales=sales.groupby([\"date_block_num\",\"shop_id\",\"item_id\"])[\"date\",\"item_price\",\"item_cnt_day\"].agg({\"date\":[\"min\",'max'],\"item_price\":\"mean\",\"item_cnt_day\":\"sum\"})",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "x=item.groupby(['item_category_id']).count()\nx=x.sort_values(by='item_id',ascending=False)\nx=x.iloc[0:10].reset_index()\n# #plot\nplt.figure(figsize=(8,4))\nax= sns.barplot(x.item_category_id, x.item_id, alpha=0.8)\nplt.title(\"Items per Category\")\nplt.ylabel('# of items', fontsize=12)\nplt.xlabel('Category', fontsize=12)\nplt.show()",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "sales.head()",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "df_sales = sales.groupby('date').item_cnt_day.sum().reset_index()\ndf_sales.head()",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "import plotly.offline as pyoff\nimport plotly.graph_objs as go\nplot_data = [\n    go.Scatter(\n        x=df_sales['date'],\n        y=df_sales['item_cnt_day'],\n    )\n]\nplot_layout = go.Layout(\n        title=' Sales'\n    )\nfig = go.Figure(data=plot_data, layout=plot_layout)\npyoff.iplot(fig)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "df_diff = df_sales.copy()\ndf_diff['prev_sales'] = df_diff['item_cnt_day'].shift(1)\ndf_diff = df_diff.dropna()\ndf_diff['diff'] = (df_diff['item_cnt_day'] - df_diff['prev_sales'])\ndf_diff.head()",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "plot_data = [\n    go.Scatter(\n        x=df_diff['date'],\n        y=df_diff['diff'],\n    )\n]\nplot_layout = go.Layout(\n        title='Montly Sales Diff'\n    )\nfig = go.Figure(data=plot_data, layout=plot_layout)\npyoff.iplot(fig)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "df_supervised = df_diff.drop(['prev_sales'],axis=1)\nfor inc in range(1,13):\n    field_name = 'lag_' + str(inc)\n    df_supervised[field_name] = df_supervised['diff'].shift(inc)\ndf_supervised = df_supervised.dropna().reset_index(drop=True)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "df_supervised.head()",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "import statsmodels.formula.api as smf\n# Define the regression formula\nmodel = smf.ols(formula='diff ~ lag_1', data=df_supervised)\n# Fit the regression\nmodel_fit = model.fit()\n# Extract the adjusted r-squared\nregression_adj_rsq = model_fit.rsquared_adj\nprint(regression_adj_rsq)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "import statsmodels.formula.api as smf\n# Define the regression formula\nmodel = smf.ols(formula='diff ~ lag_1+lag_2+lag_3+lag_4+lag_5+lag_6+lag_7+lag_8+lag_9+lag_10+lag_11+lag_12', data=df_supervised)\n# Fit the regression\nmodel_fit = model.fit()\n# Extract the adjusted r-squared\nregression_adj_rsq = model_fit.rsquared_adj\nprint(regression_adj_rsq)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "from sklearn.preprocessing import MinMaxScaler\ndf_model = df_supervised.drop(['item_cnt_day','date'],axis=1)\ntrain_set, test_set = df_model[0:-6].values, df_model[-6:].values",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "test_set",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "scaler = MinMaxScaler(feature_range=(-1, 1))\nscaler = scaler.fit(train_set)\n\ntrain_set = train_set.reshape(train_set.shape[0], train_set.shape[1])\ntrain_set_scaled = scaler.transform(train_set)\n\ntest_set = test_set.reshape(test_set.shape[0], test_set.shape[1])\ntest_set_scaled = scaler.transform(test_set)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "X_train, y_train = train_set_scaled[:, 1:], train_set_scaled[:, 0:1]\nX_train = X_train.reshape(X_train.shape[0], 1, X_train.shape[1])\nX_test, y_test = test_set_scaled[:, 1:], test_set_scaled[:, 0:1]\nX_test = X_test.reshape(X_test.shape[0], 1, X_test.shape[1])",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "import keras\nfrom keras.layers import Dense\nfrom keras.models import Sequential\nfrom keras.optimizers import Adam \nfrom keras.callbacks import EarlyStopping\nfrom keras.utils import np_utils\nfrom keras.layers import LSTM\nfrom sklearn.model_selection import KFold, cross_val_score, train_test_split\nmodel = Sequential()\nmodel.add(LSTM(4, batch_input_shape=(1, X_train.shape[1], X_train.shape[2]), stateful=True))\nmodel.add(Dense(1))\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nmodel.fit(X_train, y_train, nb_epoch=50, batch_size=1, verbose=1, shuffle=False)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "y_pred = model.predict(X_test,batch_size=1)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "import numpy as np\ny_pred = y_pred.reshape(y_pred.shape[0], 1, y_pred.shape[1])\n\npred_test_set = []\nfor index in range(0,len(y_pred)):\n    print (np.concatenate([y_pred[index],X_test[index]],axis=1))\n    pred_test_set.append(np.concatenate([y_pred[index],X_test[index]],axis=1))\n\npred_test_set = np.array(pred_test_set)\npred_test_set = pred_test_set.reshape(pred_test_set.shape[0], pred_test_set.shape[2])\n\npred_test_set_inverted = scaler.inverse_transform(pred_test_set)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "result_list = []\nsales_dates = list(sales[-7:].date)\nact_sales = list(sales[-7:].item_cnt_day)\nfor index in range(0,len(pred_test_set_inverted)):\n    result_dict = {}\n    result_dict['pred_value'] = int(pred_test_set_inverted[index][0] + act_sales[index])\n    result_dict['date'] = sales_dates[index+1]\n    result_list.append(result_dict)\ndf_result = pd.DataFrame(result_list)",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "df_result.to_csv(\"Predict.csv\")",
            "execution_count": null,
            "outputs": []
        },
        {
            "metadata": {
                "trusted": true
            },
            "cell_type": "code",
            "source": "",
            "execution_count": null,
            "outputs": []
        }
    ],
    "metadata": {
        "kernelspec": {
            "language": "python",
            "display_name": "Python 3",
            "name": "python3"
        },
        "language_info": {
            "pygments_lexer": "ipython3",
            "nbconvert_exporter": "python",
            "version": "3.6.4",
            "file_extension": ".py",
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "name": "python",
            "mimetype": "text/x-python"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 1
}