content,tag,output_type,original_content,y_pred
SETUP CHECKPOINT ASSIGN = Tokenizer() ASSIGN.fit_on_texts(label) ASSIGN = tokenizer_label.word_index ASSIGN = tokenizer_label.texts_to_sequences(label) print(ASSIGN) print(ASSIGN),1,not_existent,### Tokenize the label data from tensorflow.keras.preprocessing.text import Tokenizer from tensorflow.keras.preprocessing.sequence import pad_sequences tokenizer_label = Tokenizer()  # Get the token dict from data tokenizer_label.fit_on_texts(label) label_word_index = tokenizer_label.word_index label_seq = tokenizer_label.texts_to_sequences(label)  print(label_seq) print(label_word_index),0
"SETUP """""" A Python Module to do automated Exploratory Data Analysis and some light weight data prep. https:path """""" ASSIGN = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64'] def full_report(df, target_column=None): """"""Tries to run every possible report on the provided dataframe"""""" display(HTML(""<h1>Lazy EDA Report<path>"")) breakdown_date(df) show_dtypes(df) plot_nulls(df) plot_long_lat(df, target_column) if target_column is not None: plot_scatter_target(df, target_column) plot_hist_target(df, target_column) plot_correlations(df, target_column) def plot_correlations(df, target_column): display(HTML(""<h2>Column Data Types<path>"")) display(HTML(""<p>Below is a plot of the correlation coefficients of the dataframe's numeric columns and the target column<path>"")) ASSIGN = df.select_dtypes(include=numerics) del(ASSIGN[target_column]) ASSIGN.corrwith(df[target_column]).sort_values(ascending=False).plot( ASSIGN='barh', figsize=(12,12), title=""Correlation Coefficient with Target"") plt.show() def breakdown_date(df): """""" Creates new columns in a dataframe representing the components of a date (year, month, day of year, & week day name) """""" ASSIGN = df.dtypes[df.dtypes == 'datetime64[ns]'].index display(HTML(""<h2>Breaking down date columns<path>"")) if len(ASSIGN) > 0: display(HTML(""<p>The following columns will be broken down into year, month, day of year, and weekday columns<path> <ul>"")) for date_column in ASSIGN: display(HTML(""<li>{}<path>"".format(date_column))) df['{}_year'.format(date_column)] = df[date_column].dt.year df['{}_month'.format(date_column)] = df[date_column].dt.month df['{}_dayofyear'.format(date_column)] = df[date_column].dt.dayofyear df['{}_weekday'.format(date_column)] = df[date_column].dt.weekday_name display(HTML(""<path>"")) else: display(HTML(""<p>No Date columns found to breakdown.<path>"")) return df def plot_nulls(df): """""" Displays a horizontal bar chart representing the percentage of nulls in each column """""" display(HTML(""<h2>Plot Nulls<path>"")) ASSIGN = df.isnull().sum()path[0]*100 ASSIGN = null_percentage[null_percentage > 0].sort_values() if len(ASSIGN) > 0: display(HTML(""<p>The plot below shows the percentage of NaNs in each column in the dataframe<path>"")) ASSIGN.plot(ASSIGN='barh', figsize=(12,12), title=""Plot Null Percentages"") plt.show() else: display(HTML(""<p>The dataframe does not contain any missing data<path>"")) return null_percentage_filtered def show_dtypes(df): """"""Shows the data types of all columns"""""" display(HTML(""<h2>Column Data Types<path>"")) ASSIGN = pd.options.display.max_rows pd.options.display.max_rows = len(df.columns) ASSIGN = pd.DataFrame({""Column Name"": df.dtypes.index,""DType"": df.dtypes.values}) display(ASSIGN) pd.options.display.max_rows = ASSIGN def plot_scatter_target(df, target_column): """"""Plots a sorted scatter plot of the values in a numerical target column"""""" display(HTML(""<h2>Plot Scatter Target<path>"")) display(HTML(""<p>Below is a sorted scatter plot of the values in the target column<path>"")) plt.scatter(range(df[target_column].shape[0]), np.sort(df[target_column].values)) plt.xlabel('index', fontsize=12) plt.ylabel(target_column, fontsize=12) plt.show() def plot_hist_target(df, target_column): display(HTML(""<h2>Plot Histogram Target<path>"")) display(HTML(""<p>Below is a histogram of the values in the target column<path>"")) ASSIGN = np.percentile(df.logerror.values, 99) ASSIGN = np.percentile(df.logerror.values, 1) ASSIGN = ASSIGN df['tempTarget'].ix[df['tempTarget']>ASSIGN] = ASSIGN df['tempTarget'].ix[df['tempTarget']<ASSIGN] = ASSIGN plt.figure(figsize=(12,8)) sns.distplot(df['tempTarget']) plt.xlabel(target_column, fontsize=12) plt.show() del[df['tempTarget']] def plot_long_lat(df, target_column): if 'latitude' in df.columns.str.lower() and 'longitude' in df.columns.str.lower(): display(HTML(""<h2>Plot longitudepath<path>"")) display(HTML(""<p>Below is a scatter plot of longpath<path>"")) plt.figure(figsize=(12,12)) if target_column is None: sns.jointplot(x=df.latitude.values, y=df.longitude.values, size=10) else: ASSIGN = (ASSIGN - ASSIGN.min())path(ASSIGN.max() - ASSIGN.min()) plt.scatter(x=df.latitude.values, y=df.longitude.values, c=df['tempTarget'].values) del(df['tempTarget']) plt.ylabel('Longitude', fontsize=12) plt.xlabel('Latitude', fontsize=12) plt.show()",1,not_existent,"""""""   A Python Module to do automated Exploratory Data Analysis and some light weight data prep.  https://github.com/TareqAlKhatib/Lazy-EDA  """"""  import numpy as np  import pandas as pd  import matplotlib.pyplot as plt  import seaborn as sns  from IPython.display import display, HTML    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']        def full_report(df, target_column=None):  	""""""Tries to run every possible report on the provided dataframe""""""  	display(HTML(""<h1>Lazy EDA Report</h1>""))  	  	breakdown_date(df)  	show_dtypes(df)  	plot_nulls(df)  	plot_long_lat(df, target_column)  	if target_column is not None:  		plot_scatter_target(df, target_column)  		plot_hist_target(df, target_column)  		plot_correlations(df, target_column)                def plot_correlations(df, target_column):  	display(HTML(""<h2>Column Data Types</h2>""))  	display(HTML(""<p>Below is a plot of the correlation coefficients of the dataframe's numeric columns and the target column</p>""))  	  	num_df = df.select_dtypes(include=numerics)  	del(num_df[target_column])  	num_df.corrwith(df[target_column]).sort_values(ascending=False).plot(  		kind='barh', figsize=(12,12), title=""Correlation Coefficient with Target"")  	plt.show()  	  def breakdown_date(df):  	""""""  	Creates new columns in a dataframe representing the components of a date (year, month, day of year, & week day name)  	""""""  	date_cols = df.dtypes[df.dtypes == 'datetime64[ns]'].index  	display(HTML(""<h2>Breaking down date columns</h2>""))  	if len(date_cols) > 0:  		display(HTML(""<p>The following columns will be broken down into year, month, day of year, and weekday columns</p> <ul>""))  		  		for date_column in date_cols:  			display(HTML(""<li>{}</li>"".format(date_column)))  			df['{}_year'.format(date_column)] = df[date_column].dt.year  			df['{}_month'.format(date_column)] = df[date_column].dt.month  			df['{}_dayofyear'.format(date_column)] = df[date_column].dt.dayofyear  			df['{}_weekday'.format(date_column)] = df[date_column].dt.weekday_name  		  		display(HTML(""</ul>""))  	else:  		display(HTML(""<p>No Date columns found to breakdown.</p>""))  		  	return df    def plot_nulls(df):  	""""""  	Displays a horizontal bar chart representing the percentage of nulls in each column  	""""""  	display(HTML(""<h2>Plot Nulls</h2>""))  	  	null_percentage = df.isnull().sum()/df.shape[0]*100  	null_percentage_filtered = null_percentage[null_percentage > 0].sort_values()  	  	if len(null_percentage_filtered) > 0:  		display(HTML(""<p>The plot below shows the percentage of NaNs in each column in the dataframe</p>""))  		null_percentage_filtered.plot(kind='barh', figsize=(12,12), title=""Plot Null Percentages"")  		plt.show()  		  	else:  		display(HTML(""<p>The dataframe does not contain any missing data</p>""))  	return null_percentage_filtered    def show_dtypes(df):  	""""""Shows the data types of all columns""""""  	  	display(HTML(""<h2>Column Data Types</h2>""))  	  	# Saving the old display max  	old_max = pd.options.display.max_rows  	pd.options.display.max_rows = len(df.columns)  	  	# Display DTypes  	dtype_df = pd.DataFrame({""Column Name"": df.dtypes.index,""DType"": df.dtypes.values})  	display(dtype_df)  	  	# Restoring the old display max  	pd.options.display.max_rows = old_max  	  def plot_scatter_target(df, target_column):  	""""""Plots a sorted scatter plot of the values in a numerical target column""""""  	display(HTML(""<h2>Plot Scatter Target</h2>""))  	display(HTML(""<p>Below is a sorted scatter plot of the values in the target column</p>""))  	  	plt.scatter(range(df[target_column].shape[0]), np.sort(df[target_column].values))  	plt.xlabel('index', fontsize=12)  	plt.ylabel(target_column, fontsize=12)  	plt.show()    def plot_hist_target(df, target_column):  	display(HTML(""<h2>Plot Histogram Target</h2>""))  	display(HTML(""<p>Below is a histogram of the values in the target column</p>""))  	  	# Filter 1st and 99th percentiles  	ulimit = np.percentile(df.logerror.values, 99)  	llimit = np.percentile(df.logerror.values, 1)  	df['tempTarget'] = df[target_column]  	df['tempTarget'].ix[df['tempTarget']>ulimit] = ulimit  	df['tempTarget'].ix[df['tempTarget']<llimit] = llimit  	  	# Plot  	plt.figure(figsize=(12,8))  	sns.distplot(df['tempTarget'])  	plt.xlabel(target_column, fontsize=12)  	plt.show()  	  	del[df['tempTarget']]  	  def plot_long_lat(df, target_column):  	if 'latitude' in df.columns.str.lower() and 'longitude' in df.columns.str.lower():  		display(HTML(""<h2>Plot longitude/latitude</h2>""))  		display(HTML(""<p>Below is a scatter plot of long/lat coordinate in the dataframe</p>""))  		  		plt.figure(figsize=(12,12))  		  		if target_column is None:  			sns.jointplot(x=df.latitude.values, y=df.longitude.values, size=10)  		else:  			df['tempTarget'] = (df['logerror'] - df['logerror'].min())/(df['logerror'].max() - df['logerror'].min())  			plt.scatter(x=df.latitude.values, y=df.longitude.values, c=df['tempTarget'].values)  			del(df['tempTarget'])  		plt.ylabel('Longitude', fontsize=12)  		plt.xlabel('Latitude', fontsize=12)  		plt.show() ",0
"SETUP CHECKPOINT ASSIGN=codiv_country_short.drop([ 'Deaths Ratio','Total Infected', 'Total Deaths', 'Total Recovered', 'Total Active','Total Recovered Log10','Total Infected Log10','Total Deaths Log10','Total Active Log10'], axis=1) for col in ASSIGN.loc[:, ASSIGN.dtypes == np.number].keys(): sns.jointplot(codiv_country_short['Total Infected Log10'], col, data=codiv_country_short, height=6, s=1, color=""blue"") ASSIGN = pearsonr(codiv_country_short['Total Infected Log10'], codiv_country_short[col]) print( %(col, corr)) sns.jointplot(codiv_country_short['Total Deaths Log10'], col, data=codiv_country_short, height=6, s=1, color=""red"") ASSIGN = pearsonr(codiv_country_short['Total Deaths Log10'], codiv_country_short[col]) print( %(col, corr)) sns.jointplot(codiv_country_short['Total Active Log10'], col, data=codiv_country_short, height=6, s=1, color=""green"") ASSIGN = pearsonr(codiv_country_short['Total Active Log10'], codiv_country_short[col]) print( %(col, corr)) sns.jointplot(codiv_country_short['Deaths Ratio'], col, data=codiv_country_short, height=6, s=1, color=""orange"") ASSIGN = pearsonr(codiv_country_short['Deaths Ratio'], codiv_country_short[col]) print( %(col, corr)) plt.show()",1,stream,"import seaborn as sns  import numpy as np  from scipy.stats import pearsonr  #I use a temp table to hide some columns not needed for the sns.  codiv_country_short_tmp=codiv_country_short.drop([ 'Deaths Ratio','Total Infected', 'Total Deaths', 'Total Recovered', 'Total Active','Total Recovered Log10','Total Infected Log10','Total Deaths Log10','Total Active Log10'], axis=1)  for col in codiv_country_short_tmp.loc[:, codiv_country_short_tmp.dtypes == np.number].keys():      sns.jointplot(codiv_country_short['Total Infected Log10'], col, data=codiv_country_short, height=6, s=1, color=""blue"")      corr, _ = pearsonr(codiv_country_short['Total Infected Log10'], codiv_country_short[col])      print(""Pearsons correlation Total Infected Log10 <-> %s : %.3f"" %(col, corr))      sns.jointplot(codiv_country_short['Total Deaths Log10'], col, data=codiv_country_short, height=6, s=1, color=""red"")      corr, _ = pearsonr(codiv_country_short['Total Deaths Log10'], codiv_country_short[col])      print(""Pearsons correlation Total Deaths Log10 <-> %s : %.3f"" %(col, corr))      sns.jointplot(codiv_country_short['Total Active Log10'], col, data=codiv_country_short, height=6, s=1, color=""green"")      corr, _ = pearsonr(codiv_country_short['Total Active Log10'], codiv_country_short[col])      print(""Pearsons correlation Total Active Log10 <-> %s : %.3f"" %(col, corr))      sns.jointplot(codiv_country_short['Deaths Ratio'], col, data=codiv_country_short, height=6, s=1, color=""orange"")      corr, _ = pearsonr(codiv_country_short['Deaths Ratio'], codiv_country_short[col])      print(""Pearsons correlation Deaths Ratio <-> %s : %.3f"" %(col, corr))  plt.show()",0
"SETUP AutoMinorLocator) ASSIGN= codiv_country_qurantine_confirmed.shape fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40)) ASSIGN = pd.Series( np.random.randn(col-1), ASSIGN=pd.date_range('20path', periods=col-1)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_qurantine_confirmed.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_qurantine_confirmed.set_index('Countrypath').index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_Restrictions_confirmed.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_Restrictions_confirmed.set_index('Countrypath').index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_confirmed.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_without_Restrictions_qurantine_confirmed.set_index('Countrypath').index)) ax0.plot(ASSIGN.ASSIGN,ASSIGN) ax1.plot(ASSIGN.ASSIGN, ASSIGN) ax2.plot(ASSIGN.ASSIGN, ASSIGN) ax0.set_title(""quarantine_confirmed"") ax1.set_title(""Restrictions_confirmed"") ax2.set_title(""without_Restrictions_quarantine_confirmed"") ax0.legend(codiv_country_qurantine_confirmed['Countrypath'].tolist(),loc='upper left') ax1.legend(codiv_country_Restrictions_confirmed['Countrypath'].tolist(),loc='upper left') ax2.legend(codiv_country_without_Restrictions_qurantine_confirmed['Countrypath'].tolist(),loc='upper left') ax0.set_ylabel(""quarantine_confirmed"") ax1.set_ylabel(""Restrictions_confirmed"") ax2.set_ylabel(""without_Restrictions_quarantine_confirmed"") ax0.grid(True) ax0.xaxis.set_minor_locator(AutoMinorLocator()) ax1.grid(True) ax1.xaxis.set_minor_locator(AutoMinorLocator()) ax2.grid(True) ax2.xaxis.set_minor_locator(AutoMinorLocator()) ax0.tick_params(axis=""x"", rotation=45) ax1.tick_params(axis=""x"", rotation=45) ax2.tick_params(axis=""x"", rotation=45) for countryindex in codiv_country_qurantine_confirmed['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"": QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0] QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%mpath%dpath%Y"") ASSIGN=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0] ax0.annotate('Quarantine', (QuarantineTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top') for countryindex in codiv_country_Restrictions_confirmed['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"": RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0] RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%mpath%dpath%Y"") ASSIGN=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0] ax1.annotate('Restrictions', (RestrictionsTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top')",1,display_data,"import datetime  from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,                                 AutoMinorLocator)  row, col= codiv_country_qurantine_confirmed.shape  fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40))  ts = pd.Series(      np.random.randn(col-1),      index=pd.date_range('20/1/2020', periods=col-1))  df_qua_conf = pd.DataFrame((np.log1p(codiv_country_qurantine_confirmed.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_qurantine_confirmed.set_index('Country/Region').index))  df_res_conf = pd.DataFrame((np.log1p(codiv_country_Restrictions_confirmed.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_Restrictions_confirmed.set_index('Country/Region').index))  df_whi_conf = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_confirmed.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_without_Restrictions_qurantine_confirmed.set_index('Country/Region').index))    ax0.plot(df_qua_conf.index,df_qua_conf)  ax1.plot(df_res_conf.index, df_res_conf)  ax2.plot(df_whi_conf.index, df_whi_conf)  ax0.set_title(""quarantine_confirmed"")  ax1.set_title(""Restrictions_confirmed"")  ax2.set_title(""without_Restrictions_quarantine_confirmed"")  ax0.legend(codiv_country_qurantine_confirmed['Country/Region'].tolist(),loc='upper left')  ax1.legend(codiv_country_Restrictions_confirmed['Country/Region'].tolist(),loc='upper left')  ax2.legend(codiv_country_without_Restrictions_qurantine_confirmed['Country/Region'].tolist(),loc='upper left')  ax0.set_ylabel(""quarantine_confirmed"")  ax1.set_ylabel(""Restrictions_confirmed"")  ax2.set_ylabel(""without_Restrictions_quarantine_confirmed"")    ax0.grid(True)  ax0.xaxis.set_minor_locator(AutoMinorLocator())  ax1.grid(True)  ax1.xaxis.set_minor_locator(AutoMinorLocator())  ax2.grid(True)  ax2.xaxis.set_minor_locator(AutoMinorLocator())  ax0.tick_params(axis=""x"", rotation=45)  ax1.tick_params(axis=""x"", rotation=45)  ax2.tick_params(axis=""x"", rotation=45)  ####  for countryindex in codiv_country_qurantine_confirmed['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"":              QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]              QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%m/%d/%Y"")              Centervalue=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0]              ax0.annotate('Quarantine', (QuarantineTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')  ####  for countryindex in codiv_country_Restrictions_confirmed['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"":              RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]              RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%m/%d/%Y"")              Centervalue=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0]              ax1.annotate('Restrictions', (RestrictionsTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')",0
"SETUP AutoMinorLocator) ASSIGN= codiv_country_qurantine_deaths.shape fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40)) ASSIGN = pd.Series( np.random.randn(col-1), ASSIGN=pd.date_range('20path', periods=col-1)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_qurantine_deaths.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_qurantine_deaths.set_index('Countrypath').index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_Restrictions_deaths.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_Restrictions_deaths.set_index('Countrypath').index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_deaths.set_index('Countrypath').T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_without_Restrictions_qurantine_deaths.set_index('Countrypath').index)) ax0.plot(ASSIGN.ASSIGN,ASSIGN) ax1.plot(ASSIGN.ASSIGN, ASSIGN) ax2.plot(ASSIGN.ASSIGN, ASSIGN) ax0.set_title(""quarantine_deaths"") ax1.set_title(""Restrictions_deaths"") ax2.set_title(""without_Restrictions_quarantine_deaths"") ax0.legend(codiv_country_qurantine_deaths['Countrypath'].tolist(),loc='upper left') ax1.legend(codiv_country_Restrictions_deaths['Countrypath'].tolist(),loc='upper left') ax2.legend(codiv_country_without_Restrictions_qurantine_deaths['Countrypath'].tolist(),loc='upper left') ax0.set_ylabel(""quarantine_deaths"") ax1.set_ylabel(""Restrictions_deaths"") ax2.set_ylabel(""without_Restrictions_quarantine_deaths"") ax0.grid(True) ax0.xaxis.set_minor_locator(AutoMinorLocator()) ax1.grid(True) ax1.xaxis.set_minor_locator(AutoMinorLocator()) ax2.grid(True) ax2.xaxis.set_minor_locator(AutoMinorLocator()) ax0.tick_params(axis=""x"", rotation=45) ax1.tick_params(axis=""x"", rotation=45) ax2.tick_params(axis=""x"", rotation=45) for countryindex in codiv_country_qurantine_deaths['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"": QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0] QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%mpath%dpath%Y"") ASSIGN=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0] ax0.annotate('Quarantine', (QuarantineTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top') for countryindex in codiv_country_Restrictions_deaths['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"": RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0] RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%mpath%dpath%Y"") ASSIGN=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0] ax1.annotate('Restrictions', (RestrictionsTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top')",1,display_data,"import datetime  from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,                                 AutoMinorLocator)  row, col= codiv_country_qurantine_deaths.shape  fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40))  ts = pd.Series(      np.random.randn(col-1),      index=pd.date_range('20/1/2020', periods=col-1))  df_qua_conf = pd.DataFrame((np.log1p(codiv_country_qurantine_deaths.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_qurantine_deaths.set_index('Country/Region').index))  df_res_conf = pd.DataFrame((np.log1p(codiv_country_Restrictions_deaths.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_Restrictions_deaths.set_index('Country/Region').index))  df_whi_conf = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_deaths.set_index('Country/Region').T).to_numpy()),      index=ts.index,      columns=list(codiv_country_without_Restrictions_qurantine_deaths.set_index('Country/Region').index))    ax0.plot(df_qua_conf.index,df_qua_conf)  ax1.plot(df_res_conf.index, df_res_conf)  ax2.plot(df_whi_conf.index, df_whi_conf)  ax0.set_title(""quarantine_deaths"")  ax1.set_title(""Restrictions_deaths"")  ax2.set_title(""without_Restrictions_quarantine_deaths"")  ax0.legend(codiv_country_qurantine_deaths['Country/Region'].tolist(),loc='upper left')  ax1.legend(codiv_country_Restrictions_deaths['Country/Region'].tolist(),loc='upper left')  ax2.legend(codiv_country_without_Restrictions_qurantine_deaths['Country/Region'].tolist(),loc='upper left')  ax0.set_ylabel(""quarantine_deaths"")  ax1.set_ylabel(""Restrictions_deaths"")  ax2.set_ylabel(""without_Restrictions_quarantine_deaths"")    ax0.grid(True)  ax0.xaxis.set_minor_locator(AutoMinorLocator())  ax1.grid(True)  ax1.xaxis.set_minor_locator(AutoMinorLocator())  ax2.grid(True)  ax2.xaxis.set_minor_locator(AutoMinorLocator())  ax0.tick_params(axis=""x"", rotation=45)  ax1.tick_params(axis=""x"", rotation=45)  ax2.tick_params(axis=""x"", rotation=45)  ####  for countryindex in codiv_country_qurantine_deaths['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"":              QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]              QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%m/%d/%Y"")              Centervalue=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0]              ax0.annotate('Quarantine', (QuarantineTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')  ####  for countryindex in codiv_country_Restrictions_deaths['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"":              RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]              RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%m/%d/%Y"")              Centervalue=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0]              ax1.annotate('Restrictions', (RestrictionsTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')",0
"SETUP AutoMinorLocator) ASSIGN= codiv_country_qurantine_active.shape fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40)) ASSIGN = pd.Series( np.random.randn(col), ASSIGN=pd.date_range('20path', periods=col)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_qurantine_active.T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_qurantine_active.index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_Restrictions_active.T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_Restrictions_active.index)) ASSIGN = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_active.T).to_numpy()), ASSIGN=ts.ASSIGN, ASSIGN=list(codiv_country_without_Restrictions_qurantine_active.index)) ax0.plot(ASSIGN.ASSIGN,ASSIGN) ax1.plot(ASSIGN.ASSIGN, ASSIGN) ax2.plot(ASSIGN.ASSIGN, ASSIGN) ax0.set_title(""quarantine_active"") ax1.set_title(""Restrictions_active"") ax2.set_title(""without_Restrictions_quarantine_active"") ax0.legend(codiv_country_qurantine_deaths['Countrypath'].tolist(),loc='upper left') ax1.legend(codiv_country_Restrictions_deaths['Countrypath'].tolist(),loc='upper left') ax2.legend(codiv_country_without_Restrictions_qurantine_deaths['Countrypath'].tolist(),loc='upper left') ax0.set_ylabel(""quarantine_active"") ax1.set_ylabel(""Restrictions_active"") ax2.set_ylabel(""without_Restrictions_qurantine_active"") ax0.grid(True) ax0.xaxis.set_minor_locator(AutoMinorLocator()) ax1.grid(True) ax1.xaxis.set_minor_locator(AutoMinorLocator()) ax2.grid(True) ax2.xaxis.set_minor_locator(AutoMinorLocator()) ax0.tick_params(axis=""x"", rotation=45) ax1.tick_params(axis=""x"", rotation=45) ax2.tick_params(axis=""x"", rotation=45) for countryindex in codiv_country_qurantine_deaths['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"": QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0] QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%mpath%dpath%Y"") ASSIGN=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0] ax0.annotate('Quarantine', (QuarantineTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top') for countryindex in codiv_country_Restrictions_deaths['Countrypath']: if not codiv_country[codiv_country['Country']==countryindex].empty : if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"": RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0] RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%mpath%dpath%Y"") ASSIGN=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0] ax1.annotate('Restrictions', (RestrictionsTimeD, ASSIGN), ASSIGN=(0.2, 0.95), textcoords='axes fraction', ASSIGN=dict(facecolor='red', shrink=0.001), ASSIGN=16, ASSIGN='right', verticalalignment='top')",1,display_data,"import datetime  from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,                                 AutoMinorLocator)  row, col= codiv_country_qurantine_active.shape  fig, (ax0,ax1,ax2) = plt.subplots(3, sharey=True,figsize=(25,40))  ts = pd.Series(      np.random.randn(col),      index=pd.date_range('20/1/2020', periods=col))  df_qua_conf = pd.DataFrame((np.log1p(codiv_country_qurantine_active.T).to_numpy()),      index=ts.index,      columns=list(codiv_country_qurantine_active.index))  df_res_conf = pd.DataFrame((np.log1p(codiv_country_Restrictions_active.T).to_numpy()),      index=ts.index,      columns=list(codiv_country_Restrictions_active.index))  df_whi_conf = pd.DataFrame((np.log1p(codiv_country_without_Restrictions_qurantine_active.T).to_numpy()),      index=ts.index,      columns=list(codiv_country_without_Restrictions_qurantine_active.index))    ax0.plot(df_qua_conf.index,df_qua_conf)  ax1.plot(df_res_conf.index, df_res_conf)  ax2.plot(df_whi_conf.index, df_whi_conf)  ax0.set_title(""quarantine_active"")  ax1.set_title(""Restrictions_active"")  ax2.set_title(""without_Restrictions_quarantine_active"")  ax0.legend(codiv_country_qurantine_deaths['Country/Region'].tolist(),loc='upper left')  ax1.legend(codiv_country_Restrictions_deaths['Country/Region'].tolist(),loc='upper left')  ax2.legend(codiv_country_without_Restrictions_qurantine_deaths['Country/Region'].tolist(),loc='upper left')  ax0.set_ylabel(""quarantine_active"")  ax1.set_ylabel(""Restrictions_active"")  ax2.set_ylabel(""without_Restrictions_qurantine_active"")    ax0.grid(True)  ax0.xaxis.set_minor_locator(AutoMinorLocator())  ax1.grid(True)  ax1.xaxis.set_minor_locator(AutoMinorLocator())  ax2.grid(True)  ax2.xaxis.set_minor_locator(AutoMinorLocator())  ax0.tick_params(axis=""x"", rotation=45)  ax1.tick_params(axis=""x"", rotation=45)  ax2.tick_params(axis=""x"", rotation=45)  ####  for countryindex in codiv_country_qurantine_deaths['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]!=""2000-01-01"" and countryindex!=""New Zealand"":              QuarantineTime=codiv_country[codiv_country['Country']==countryindex]['Quarantine'].values[0]              QuarantineTimeD = datetime.datetime.strptime(str(QuarantineTime), ""%m/%d/%Y"")              Centervalue=df_qua_conf[df_qua_conf.index==QuarantineTimeD][countryindex].values[0]              ax0.annotate('Quarantine', (QuarantineTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')  ####  for countryindex in codiv_country_Restrictions_deaths['Country/Region']:      if not codiv_country[codiv_country['Country']==countryindex].empty :          if codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]!=""2000-01-01"":              RestrictionsTime=codiv_country[codiv_country['Country']==countryindex]['Restrictions'].values[0]              RestrictionsTimeD = datetime.datetime.strptime(str(RestrictionsTime), ""%m/%d/%Y"")              Centervalue=df_res_conf[df_res_conf.index==RestrictionsTimeD][countryindex].values[0]              ax1.annotate('Restrictions', (RestrictionsTimeD, Centervalue),                  xytext=(0.2, 0.95), textcoords='axes fraction',                  arrowprops=dict(facecolor='red', shrink=0.001),                  fontsize=16,                  horizontalalignment='right', verticalalignment='top')",0
"SETUP def Polifq(Country,Version=""restrictions"",shift=0,trigger=40): ASSIGN==""restrictions"": ASSIGN=codiv_country_Restrictions_active.T[Country] else: ASSIGN==""quarantine"": ASSIGN=codiv_country_qurantine_active.T[Country] else: ASSIGN=codiv_country_without_Restrictions_qurantine_active.T[Country] StartCountryIndex=0 ShiftIndex=0 ASSIGN=0 ASSIGN=0 ASSIGN=1.0 LargeFactor=1.0 ASSIGN = np.abs(df_codiv - df_codiv.mean()) > (3 * df_codiv.std()) ASSIGN = df_codiv.loc[filter0] ASSIGN = ASSIGN.drop(outliers.index, axis=0) ASSIGN=max(df_codiv) ASSIGN = pd.DataFrame(columns = [Country,""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [Country,""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[Country] ASSIGN = np.polyfit(x_tr1_Country, y_tr1_Country, deg=10) ASSIGN=0 ASSIGN==1: ASSIGN=1 ASSIGN=max(codiv_country_qurantine_active.T[""China""]) for Index in range(0,len(ASSIGN)): if ASSIGN[Index]>trigger*(ASSIGN*1.0path) and ASSIGN==1 and shift==1: if ASSIGN>ASSIGN: ASSIGN=ASSIGN*(maxCountry*1.5path) StartCountryIndex=Index ASSIGN=0 if ASSIGN[Index]==ASSIGN: ASSIGN=Index LargeCountry=ASSIGN-StartCountryIndex ASSIGN=codiv_country_qurantine_active.T[""China""] ASSIGN = np.abs(df_codiv_China_ref - df_codiv_China_ref.mean()) > (3 * df_codiv_China_ref.std()) ASSIGN = df_codiv_China_ref.loc[filter0] ASSIGN = df_codiv_China_ref.drop(outliers.index, axis=0) ASSIGN=max(df_codiv_China_ref) ASSIGN=1 for Index in range(0,len(ASSIGN)): if ASSIGN[Index]>60 and ASSIGN==1 and shift==1: StartChinaIndex=Index ASSIGN=0 if ASSIGN[Index]==ASSIGN: ASSIGN=Index ASSIGN=maxCountry*1.0path LargeChina=ASSIGN-StartChinaIndex LargeFactor=LargeCountry*1.0path ShiftIndex=StartCountryIndex-StartChinaIndex ASSIGN=0.02 ASSIGN = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[""China""] ASSIGN = rmse(y_tr1_China_model,y_tr1_Country) ASSIGN=0 for runNr in range(1,60,1): if ASSIGN<ASSIGN: LargeFactor=LargeFactor+ASSIGN ASSIGN=error1 ASSIGN = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[""China""] ASSIGN = rmse(y_tr1_China_model,y_tr1_Country) if ASSIGN<ASSIGN: LargeFactor=LargeFactor+ASSIGN ASSIGN=error1 ASSIGN = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[""China""] ASSIGN = rmse(y_tr1_China_model,y_tr1_Country) if ASSIGN<ASSIGN: ASSIGN=ASSIGN+step ASSIGN=error1 ASSIGN = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[""China""] ASSIGN = rmse(y_tr1_China_model,y_tr1_Country) if ASSIGN<ASSIGN: ASSIGN=ASSIGN+step ASSIGN=error1 ASSIGN = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int') for Index in range(0,len(ASSIGN)): ASSIGN = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""]) ASSIGN=ASSIGN.append(df_codiv1, ignore_index = True) ASSIGN=df_country[""Value""] ASSIGN=df_country[""China""] ASSIGN = rmse(y_tr1_China_model,y_tr1_Country) ASSIGN = np.polyfit(x_tr1_China_model, y_tr1_China_model, deg=10) return coefs_Country_poly10,x_tr1_Country,y_tr1_Country,coefs_predict_poly10,x_tr1_China_model,y_tr1_China_model,StartCountryIndex",1,not_existent,"import scipy.stats as stats  import datetime  def Polifq(Country,Version=""restrictions"",shift=0,trigger=40):      # Version= works for restrictions, quarantin and without_Restrictions_qurantine.      if Version==""restrictions"":          df_codiv=codiv_country_Restrictions_active.T[Country]      else:          if Version==""quarantine"":              df_codiv=codiv_country_qurantine_active.T[Country]          else:              df_codiv=codiv_country_without_Restrictions_qurantine_active.T[Country]      #######################################      ######################## parameter setup      StartCountryIndex=0      ShiftIndex=0      x_tr1_China_model=0      y_tr1_China_model=0      highfactor=1.0      LargeFactor=1.0      ##############################################################################      ####################################### fitting the Country ##################      ######################## filter outlier for the Country      filter0 = np.abs(df_codiv - df_codiv.mean()) > (3 * df_codiv.std())      outliers = df_codiv.loc[filter0]      df_codiv = df_codiv.drop(outliers.index, axis=0)      ###########      # max actual value of the country      maxCountry=max(df_codiv)      #######################################      ########### Build the dataframe for the country      df_country = pd.DataFrame(columns = [Country,""Value"",""time""], dtype='int')      for Index in range(0,len(df_codiv)):          df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [Country,""Value"",""time""])          df_country=df_country.append(df_codiv1, ignore_index = True)      #######################################      #################### polyfit 10gr for the country value      x_tr1_Country=df_country[""Value""]      y_tr1_Country=df_country[Country]      #      # * Polyfit with degree 10      coefs_Country_poly10 = np.polyfit(x_tr1_Country, y_tr1_Country, deg=10) # Fit to train data      ##############################################################################      ##############################################################################      coefs_predict_poly10=0      #######################################      ############### Now shifting the china model to fitt to the country      if shift==1:          Start=1          ####### for the country          maxChina=max(codiv_country_qurantine_active.T[""China""])          for Index in range(0,len(df_codiv)):              #look for the start position of the country epidemy, it should be higher then the trigger value, it will be setup only by start of procedure ( STart=1)              if df_codiv[Index]>trigger*(maxCountry*1.0/maxChina) and Start==1 and shift==1:                                    if maxCountry>maxChina:                      trigger=trigger*(maxCountry*1.5/maxChina)                  StartCountryIndex=Index                  Start=0              # register the index of the coutry max position              if df_codiv[Index]==maxCountry:                  maxCountryIndex=Index          # deliver the actual distance between start and maximum for the country          LargeCountry=maxCountryIndex-StartCountryIndex          #################################          #######################################          ####### for china          df_codiv_China_ref=codiv_country_qurantine_active.T[""China""]          #######################################          ###### outiler          filter0 = np.abs(df_codiv_China_ref - df_codiv_China_ref.mean()) > (3 * df_codiv_China_ref.std())          outliers = df_codiv_China_ref.loc[filter0]          df_codiv = df_codiv_China_ref.drop(outliers.index, axis=0)          #######################################          ###### check for the start point by 40 infected          maxChina=max(df_codiv_China_ref)          Start=1          for Index in range(0,len(df_codiv_China_ref)):              if df_codiv_China_ref[Index]>60 and Start==1 and shift==1:                  StartChinaIndex=Index                  Start=0              if df_codiv_China_ref[Index]==maxChina:                  maxChinaIndex=Index          #######################################          ###### start value for the fitting          highfactor=maxCountry*1.0/maxChina          LargeChina=maxChinaIndex-StartChinaIndex          LargeFactor=LargeCountry*1.0/LargeChina          ShiftIndex=StartCountryIndex-StartChinaIndex          ##########OPTIMISATION           step=0.02          ############# the target          # Predictions with the current a,b values          ################# generate the function country is china          df_country = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int')          for Index in range(0,len(df_codiv)):              df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""])              df_country=df_country.append(df_codiv1, ignore_index = True)          x_tr1_China_model=df_country[""Value""]          y_tr1_China_model=df_country[""China""]                error0 = rmse(y_tr1_China_model,y_tr1_Country)          error1=0          for runNr in range(1,60,1):              if error1<error0:                  LargeFactor=LargeFactor+step                  error0=error1                  ################# generate the function                  df_country = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int')                  for Index in range(0,len(df_codiv)):                      df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""])                      df_country=df_country.append(df_codiv1, ignore_index = True)                  x_tr1_China_model=df_country[""Value""]                  y_tr1_China_model=df_country[""China""]                   error1 = rmse(y_tr1_China_model,y_tr1_Country)              if error1<error0:                  LargeFactor=LargeFactor+step                  error0=error1                  ################# generate the function                  df_country = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int')                  for Index in range(0,len(df_codiv)):                      df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""])                      df_country=df_country.append(df_codiv1, ignore_index = True)                  x_tr1_China_model=df_country[""Value""]                  y_tr1_China_model=df_country[""China""]                   error1 = rmse(y_tr1_China_model,y_tr1_Country)              ##############              if error1<error0:                  highfactor=highfactor+step                  error0=error1                  ################# generate the function                  df_country = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int')                  for Index in range(0,len(df_codiv)):                      df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""])                      df_country=df_country.append(df_codiv1, ignore_index = True)                  x_tr1_China_model=df_country[""Value""]                  y_tr1_China_model=df_country[""China""]                   error1 = rmse(y_tr1_China_model,y_tr1_Country)              #################              if error1<error0:                  highfactor=highfactor+step                  error0=error1                  ################# generate the function                  df_country = pd.DataFrame(columns = [""China"",""Value"",""time""], dtype='int')                  for Index in range(0,len(df_codiv)):                      df_codiv1 = pd.DataFrame ([[int(df_codiv[Index]*highfactor),int((Index)*LargeFactor)+ShiftIndex,str(pd.Timestamp(df_codiv.index[Index])+ pd.Timedelta(days=ShiftIndex))]], columns = [""China"",""Value"",""time""])                      df_country=df_country.append(df_codiv1, ignore_index = True)                  x_tr1_China_model=df_country[""Value""]                  y_tr1_China_model=df_country[""China""]                   error1 = rmse(y_tr1_China_model,y_tr1_Country)          #after having this fitting, we can fit the modified china data  on a 10grade polynome          #          # * Polyfit with degree 10          coefs_predict_poly10 = np.polyfit(x_tr1_China_model, y_tr1_China_model, deg=10) # Fit to train data      return coefs_Country_poly10,x_tr1_Country,y_tr1_Country,coefs_predict_poly10,x_tr1_China_model,y_tr1_China_model,StartCountryIndex",0
"pd.set_option(""display.max_columns"",2000)  # used for viewing all the columns at onces pd.set_option(""display.max_rows"",85)",1,not_existent,"# To show the all columns  pd.set_option(""display.max_columns"",2000)  # used for viewing all the columns at onces  pd.set_option(""display.max_rows"",85)",0
"SETUP CHECKPOINT ASSIGN = pd.read_csv(""..path"") ASSIGN = pd.read_csv(""..path"") ASSIGN = pd.concat((train.loc[:,'MSSubClass':'SaleCondition'], ASSIGN.loc[:,'MSSubClass':'SaleCondition'])) ASSIGN = np.log1p(ASSIGN) ASSIGN = all_data.dtypes[all_data.dtypes != ""object""].index ASSIGN = train[numeric_feats].apply(lambda x: skew(x.dropna())) ASSIGN = ASSIGN[ASSIGN > 0.75] ASSIGN = ASSIGN.index ASSIGN[ASSIGN] = np.log1p(ASSIGN[ASSIGN]) ASSIGN = pd.get_dummies(ASSIGN) ASSIGN = ASSIGN.fillna(ASSIGN.mean()) ASSIGN = all_data[:train.shape[0]] ASSIGN = all_data[train.shape[0]:] ASSIGN = train.SalePrice def rmse_cv(model): ASSIGN= np.sqrt(-cross_val_score(model, X_train, y, scoring=""neg_mean_squared_error"", cv = 5)) return(ASSIGN) ASSIGN = LassoCV(alphas = [1, 0.1, 0.001, 0.0005]).fit(X_train, y) rmse_cv(ASSIGN).mean() ASSIGN = pd.Series(model_lasso.coef_, index = X_train.columns) print( + str(sum(ASSIGN != 0)) + + str(sum(ASSIGN == 0)) + ) ASSIGN = np.expm1(model_lasso.predict(X_test)) ASSIGN = pd.DataFrame({""id"":test.Id, ""SalePrice"":lasso_preds}) ASSIGN.to_csv(""ridge_sol.csv"", index = False)",1,stream,"import pandas as pd  import numpy as np  from scipy.stats import skew    train = pd.read_csv(""../input/train.csv"")  test = pd.read_csv(""../input/test.csv"")    all_data = pd.concat((train.loc[:,'MSSubClass':'SaleCondition'],                        test.loc[:,'MSSubClass':'SaleCondition']))    train[""SalePrice""] = np.log1p(train[""SalePrice""])  numeric_feats = all_data.dtypes[all_data.dtypes != ""object""].index    skewed_feats = train[numeric_feats].apply(lambda x: skew(x.dropna()))  skewed_feats = skewed_feats[skewed_feats > 0.75]  skewed_feats = skewed_feats.index    all_data[skewed_feats] = np.log1p(all_data[skewed_feats])  all_data = pd.get_dummies(all_data)  all_data = all_data.fillna(all_data.mean())    X_train = all_data[:train.shape[0]]  X_test = all_data[train.shape[0]:]  y = train.SalePrice    from sklearn.linear_model import LassoCV  from sklearn.model_selection import cross_val_score    def rmse_cv(model):      rmse= np.sqrt(-cross_val_score(model, X_train, y, scoring=""neg_mean_squared_error"", cv = 5))      return(rmse)    model_lasso = LassoCV(alphas = [1, 0.1, 0.001, 0.0005]).fit(X_train, y)  rmse_cv(model_lasso).mean()    coef = pd.Series(model_lasso.coef_, index = X_train.columns)  print(""Lasso picked "" + str(sum(coef != 0)) + "" variables and eliminated the other "" +  str(sum(coef == 0)) + "" variables"")    lasso_preds = np.expm1(model_lasso.predict(X_test))    solution = pd.DataFrame({""id"":test.Id, ""SalePrice"":lasso_preds})  solution.to_csv(""ridge_sol.csv"", index = False)",0
"SETUP CHECKPOINT ASSIGN = np.mean(X_std, axis=0) ASSIGN = (X_std - mean_vec).T.dot((X_std - mean_vec)) path(X_std.shape[0]-1) print('Covariance matrix \n%s' %ASSIGN)",1,stream,"import numpy as np  mean_vec = np.mean(X_std, axis=0)  cov_mat = (X_std - mean_vec).T.dot((X_std - mean_vec)) / (X_std.shape[0]-1)  print('Covariance matrix \n%s' %cov_mat)",0
CHECKPOINT print(co2_levels.describe()) print(co2_levels.co2.min()) print(co2_levels.co2.max()),0,stream,# Print out summary statistics of the co2_levels DataFrame  print(co2_levels.describe())    # Print out the minima of the co2 column in the co2_levels DataFrame  print(co2_levels.co2.min())    # Print out the maxima of the co2 column in the co2_levels DataFrame  print(co2_levels.co2.max()),1
"os.environ['KAGGLE_USERNAME'] = API[""username""] os.environ['KAGGLE_KEY'] = API[""key""]",1,not_existent," os.environ['KAGGLE_USERNAME'] = API[""username""] os.environ['KAGGLE_KEY'] = API[""key""]",0
"SETUP CHECKPOINT ASSIGN = ExtraTreesRegressor(n_estimators=25,random_state=16) ASSIGN.fit(x_train,y_train.values.ravel()) ASSIGN = etr.predict(x_test) print(,r2_score(y_test,ASSIGN)) print('Mean Absolute Error:', metrics.mean_absolute_error(y_test, ASSIGN)) print('Root Mean Squared Error:', metrics.mean_squared_error(y_test, ASSIGN, squared=False))",1,stream,"from sklearn.ensemble import ExtraTreesRegressor  etr = ExtraTreesRegressor(n_estimators=25,random_state=16)  etr.fit(x_train,y_train.values.ravel())  y_pred = etr.predict(x_test)      print(""R2 Score:"",r2_score(y_test,y_pred))  print('Mean Absolute Error:', metrics.mean_absolute_error(y_test, y_pred))  print('Root Mean Squared Error:', metrics.mean_squared_error(y_test, y_pred, squared=False))",0
